{
    "contents" : "---\ntitle: \"KNOWNET - Social Network Analysis\"\noutput:\n  tufterhandout::pdf_tufte_handout:\n    keep_tex: false\n  tufterhandout::html_tufte_handout:\n    keep_md: true\n\n---\n\n\n```{r setup, include=FALSE}\nlibrary(knitr)\nlibrary(igraph)\nlibrary(knet)\nlibrary(ggplot2)\n\nopts_chunk$set(cache=TRUE)\n```\n\nIntroduction\n--------------------------------------------------------------------\n\nThis document will give a walkthrough of how to do Social Network Analysis using the knet package by example. \n\nLet's generate an undirected tree graph with 150 nodes and 4 children max per node. This can represent a regular SME company structure.\n\n```{r }\ntr <- graph.tree(200, children = 4, mode=\"undirected\")\n```\n\nCreate a graph from the tree by adding 200 random edges. It is not guaranteed that there won't be fetures like multiple edges between two nodes or loop edges due to the sampling technique used.\n```{r }\ngr <- add.edges(tr\n          , as.list( sample(V(tr),100,replace=TRUE)\n                   , sample(V(tr),100,replace=TRUE)\n                   ))\n```\n\nSimplify the graph by removing multiple edges and loops.\n```{r}\ngr <- simplify(gr, remove.multiple=TRUE, remove.loops=TRUE)\n```\n\nNetwork centralization measures\n--------------------------------------------------------------------\nThe *igraph* package implements a battery of different network measures usually used in Social Network Analysis. We will demonstrate some of them below for completeness.\n\nWe can calculate the degree centralisation of the generated tree\n```{r }\n#calculate the centralization\ncD <- centralization.degree(tr, normalized = FALSE)\n\n#print the calculated centralization\nprint(cD$centralization)\n```\n\nCalculate the normalized degree centralisation of the generated graph\n```{r }\n#calculate the normalized centralization\ncDn <- centralization.degree(tr, normalized = TRUE)\n\n#print the calculated normalized centralization\nprint(cDn$centralization)\n```\n\nAs a comparison calculate the degree centralisation of the generated graph\n```{r }\n#calculate the centralization\ncDgr <- centralization.degree(gr, normalized = FALSE)\n\n#print the calculated centralization\nprint(cDgr$centralization)\n\n#print the calculated normalized centralization\nprint(cDn$centralization)\n```\n\nPrint the theoritical maximum of the degree centrality of a graph of this size\n```{r }\n#print the theoretical maximum\nprint(cDn$theoretical_max)\n```\n\n\n\nNext we plot a histogram is to use the *hist* method. We are reusing the degrees data frame. To format the plot, we apply gray color to the bars, explictly name the x axis to \"degrees\", and leave off the main title by assigning it an *NA* value.\n```{r fig2, tidy = TRUE, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = \"Degree centrality of individual nodes with the mean degree plotted in red and the median in green\"}\nhist(  degrees$degrees\n     , col = \"gray\"\n     , labels = FALSE\n     , xlab=\"degrees\"\n     , main = NA)\n```\n\nA more flexible way to plot graphics is to use the facilities provided by the ggplot2 package. We will plot the histogram of the distribution of the degrees of the nodes, together with the *mean* and the *median*. In order tro do that, we first have to cast the calculated degrees *cD$res* to a data frame. Next we build the plot expression piecewise using the appropriate grammar for graphics (*ggplot2*) combinators for histogram and vertical lines.\n```{r fig1, tidy = TRUE, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = \"Degree centrality of individual nodes with the mean degree plotted in red and the median in green\", prompt=FALSE}\ndegrees <- cDgr$res\ndegrees <- as.data.frame(degrees)\n\np <- ggplot(degrees, aes(x=degrees)) + geom_histogram(binwidth = 1) \np <- p + geom_vline(xintercept=mean(degrees$degrees), color=\"red\")\np + geom_vline(xintercept=median(degrees$degrees), color=\"green\")\n```\n\n\nCalculate closeness centralization of the tree\n```{r }\ncC <- centralization.closeness(tr,normalized = FALSE)\n\n#print the calculated centralization\nprint(cC$centralization)\n```\n\nPlot the histogram of the closeness for individual nodes of the tree\n```{r fig3, fig.width=7, fig.height=6}\nhist(cC$res, main=\"Distribution of the closeness centrality of individual nodes\")\n```\n\nCalculate closeness centralization of the generated graph\n```{r }\ncCgr <- centralization.closeness(gr,normalized = FALSE)\n\n#print the calculated centralization\nprint(cCgr$centralization)\n```\n\nPlot the histogram of the closeness for individual nodes of the generated graph\n```{r  fig4, fig.width=7, fig.height=6}\nhist(cCgr$res, main=\"Distribution of the closeness centrality of individual nodes\")\n```\n\nCalculate the graph betweenness centralization\n```{r }\ncB <- centralization.betweenness (tr, directed = FALSE, normalized = FALSE)\n\n#print the calculated centralization\nprint(cB$centralization)\n```\n\nPlot the histogram of the betweenness centrality of individual nodes\n```{r  fig5, fig.width=7, fig.height=6}\nhist(cB$res, main=\"Distribution of the betweenness centrality of individual nodes\")\n```\n\nCalculate the graph betweenness centralization\n```{r }\ncBgr <- centralization.betweenness (gr, directed = FALSE, normalized = FALSE)\n\n#print the calculated centralization\nprint(cBgr$centralization)\n```\n\nPlot the histogram of the betweenness centrality of individual nodes\n```{r  fig6, fig.width=7, fig.height=6}\nhist(cBgr$res, main=\"Distribution of the betweenness centrality of individual nodes\")\n```\n\nClustering and cliques\n--------------------------------------------------------------------\n\nThe *transitivity* function from the *igraph* package calculates the clustering coefficient of the graph\n```{r }\nclusteringC <- transitivity(tr,type=\"globalundirected\")\n\n#print the calculated clustering coefficient of the tree\nprint(clusteringC)\n```\n\nFind the largest cliques in the graph\n```{r}\ngrC <- largest.cliques(gr)\n```\n\nPlot the graph with the cliques coloured in different colours.\n\n```{r  fig7, fig.width=7, fig.height=6}\n#a list of coulour to help with plotting the graphs\ncolours = c(\"#E4B9CD\",\"#BF6D92\",\"#8F305B\",\"#5F0930\"\n           ,\"#FFD6CF\",\"#E38F82\",\"#AA4839\",\"#71190B\"\n           ,\"#ACD3B8\",\"#60A876\",\"#2A7E43\",\"#08541F\"\n           ,\"#DFF1C4\",\"#ACD077\",\"#729C34\",\"#41680A\"\n           ,\"#B9E4CD\",\"#6DBF92\",\"#308F5B\",\"#095F30\"\n           ,\"#B9CDE4\",\"#6D92BF\",\"#305B8F\",\"#09305F\"          )\n\n#set all vertice colours to white\nV(gr)$color <- \"white\"\n\n#for all cliques set the corresponding vertice colour\nfor (i in 1:length(grC)) {\n  sel <- grC[[i]]\n  V(gr)[sel]$color <- colours[i]\n}\n\n#plot the result\nknet.plot.graph(gr)\n```\n\nPlot a clique in a separate graph\n```{r  fig8, fig.width=7, fig.height=6}\n # select the first clique\n sel <- grC[[1]]\n V(gr)$color <- \"white\"\n V(gr)[sel]$color <- \"darkorchid\"\n knet.plot.graph(gr)\n```\n\n\nFind communities in the generated graph using a model from statistical mechanics called spin-glass and change vertex colour to reflect the dicovered communities.\n```{r fig9,  fig.width=7, fig.height=6}\n\n#discover the communities in the graph using the spinglass method\ngrc <- spinglass.community(gr)\n```\nPlot the histogram of the community membership distribution\n```{r  fig10, fig.width=7, fig.height=6}\nhist(grc$membership, main=\"Histogram of community membership\")\n```\n\nPlot the graph with the communities coloured in different colours.\n\n```{r  fig11, fig.width=7, fig.height=6}\n#transfer the membership attribute from the communities object to the graph\n\ncolours = sample( rainbow( length(grc) + 1) )\nV(gr)$membership <- grc$membership\n\n#set all vertice colours to white\nV(gr)$color <- \"white\"\n\n# for each vertice select colour according tho its membership propery (clique number)\nV(gr)$color <- colours[V(gr)$membership]\n#plot the graph using the knet graph plot helper function\nknet.plot.graph(gr)\n```\n\nPlot the communities detected in the graph\n```{r  fig12, fig.width=7, fig.height=6}\nplot(grc,gr, vertex.label=NA, vertex.size=5)\n\n```\n\nUse a different community detection method - fastgreedy algorithm, for a list of other community detection algorithms and related references check the (igraph documention)[http://igraph.org]\n```{r  fig13, fig.width=7, fig.height=6}\ngfc <- fastgreedy.community(gr)\n```\n\nPlot the membership histogram\n```{r  fig14, fig.width=7, fig.height=6}\nhist(gfc$membership, main=\"Histogram of the fastgreedy community membership\")\n```\n\nPlot the graph with the communities coloured in different colours.\n```{r  fig15, fig.width=7, fig.height=6}\nplot(gfc,gr, vertex.label=NA, vertex.size=5)\n```\n\nPlot the dendogram of the community hierarchy\n```{r  fig16, fig.width=10, fig.height=8}\ndendPlot(gfc)\n```\n\nPloting\n--------------------------------------------------------------------\n\nKnowing the root element of the tree *tr* , in this case 1, we can plot the tree\n```{r  fig18, fig.width=7, fig.height=6}\nknet.plot.tree(tr,1)\n```\n\nOr we can plot it as a *regular* graph\n```{r  fig19, fig.width=7, fig.height=6}\nknet.plot.graph(tr)\n```\n\nPlot the two graph in a circular layout\n```{r  fig20, fig.width=7, fig.height=6}\nknet.plot.circular(tr)\n```\n```{r  fig21, fig.width=7, fig.height=6}\nknet.plot.circular(gr)\n\n```",
    "created" : 1405087107565.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1719405406",
    "id" : "6C07F078",
    "lastKnownWriteTime" : 1405095703,
    "path" : "D:/Vlado/Papers/org learning/knet/help/knet-r/sna.Rmd",
    "project_path" : "sna.Rmd",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}