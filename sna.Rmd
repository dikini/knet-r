---
title: "KNOWNET - a guide to data mining and social network analysis"
author: Vladimir Zlatanov
organization: Brunel University
output:
  tufterhandout::html_tufte_handout:
    keep_md: true
    pandoc_args: ["--toc"]
  tufterhandout::pdf_tufte_handout:
    keep_tex: false
    pandoc_args: ["--toc"]

bibliography: bibliography.bib
csl: harvard-style.csl
---


```{r setup, include=FALSE}
library(knet)    # KNOWNET helper utilities
library(ggplot2) # Format R data frames as LaTeX/HTML tables
library(GGally)
library(gridExtra)
library(xtable)  # Produce a flowchart.
library(diagram) # Produce a flowchart.
library(plyr)
library(igraph)  # graph manipulation and anlysis

opts_chunk$set(cache=TRUE) # caching of document output - could speed up the results
```

Introduction
=========================

This is a step by step guide on analysis and data minining developed for the needs of the KNOWNET project^[More information is avalable on the KNOWNET project website http://www.knownet.org.uk]. Basic familiarity with R [@RCoreTeam2014] would be helpful, but not essential. This document is a [literate program](http://en.wikipedia.org/wiki/Literate_programming) [@knuth1992] written in R and RMarkdown [@RStudio2014]. R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. As it provides a rich variety of tools in order to perform a variety of data mining, knowledge discovery and social network analysis tasks it was chosen as an implementation language. RStudio IDE is a powerful and productive open source user interface for R that works on Windows, MacOS, and Linux.

In order to be able to follow the guide and perform the excercises the following prerequisties ahave to be installed:  

* [R](http://www.r-project.org/) from the R Project [@RCoreTeam2014] 
* [RStudio IDE](http://www.rstudio.com) from RSrudio Inc [@RStudio2012] 
* [Pandoc](http://johnmacfarlane.net/pandoc/)^[Pandoc is a document processor/converterrequired to generetate this guide and documentation]
* [MiKTeX](http://miktex.org/)^[MikTeX is an up-to-date implementation of TeX/LaTeX and related programs for Windows (all current variants)] or another up-to-date TeX/LaTex distribution

All the required programs are available for Windows, Linux and MacOS X, but the help of a systems administrator to install the software may be required.



This guide is based on the classic Data Mining (DM) and Knowledge Discovery in Databases (KDD) processes [@Fayyad1996], consists of the following steps for exploratory analysis^[The process is repeated until the results are satisfactory] : 
 
  1. Aquisition
  1. Selection 
  2. Pre-processing 
  3. Anonymisation 
  4. Transformation 
  5. Analysis 
  6. Interpretation/Evaluation 

Data Aquisition
=======================

Acquired from Yammer using the data mining extension

```{r da1,tidy = FALSE, prompt=FALSE}
# ThreadId, From, FromId, FromModel, FromUrl, To, ToId, Message
Threads <- read.csv("data/Threads.csv", header=FALSE)
colnames(Threads) <- c("ThreadId", "From", "FromId", "FromType"
                     , "url",  "To", "ToId", "ToType","Message")

Replies <- read.csv("data/Replies.csv", header=FALSE)

#assign names to the columns
colnames(Replies) <- c("ThreadId", "From", "FromId", "FromType"
                     , "url", "To", "ToId", "Message")

```

The data imported from the two files has to be merged into a *Messages* data frame to have all of the messages in one place. In order to do that, the *Replies* data frame is augmented with the missing *From* column.
```{r}
Replies$ToType <- NA
Messages <- rbind(Threads,Replies)
```

The data as is unsuitable for publication, as it contains the real names. We first create a conversion table, the generate random names, add them to the source tables, and replace the real names with the random ones in the *Messages* table.

```{r, message=FALSE, results='asis'}
#Merge From and To names
names <- data.frame(levels(factor(c(levels(Messages$From),levels(Messages$To)))))
colnames(names) <- c("From")

#make sure we have repeatable name sequences
set.seed(123345)
names$Name <- randomNames(length(levels(names$From)),which.names="first")

Threads$Name <- names$Name[Threads$From]
Threads$ToName <- names$Name[Threads$To]

Replies$Name <- names$Name[Replies$From]
Replies$ToName <- names$Name[Replies$To]

#replace the real names with the fake ones
Messages$From <- names$Name[Messages$From]
Messages$To <- names$Name[Messages$To]

```
Data Exploration
=======================

Let's look at the first five rows and only the *From*, *To*, and *Message* columns from the *Messages* data frame. The message text is trimmed  for illustration purposes
```{r de1, results="asis", fig.cap="Extract from the messages data"}
Messages$Text <- strtrim(Messages$Message,30)
# switch comments if generating pdf
 print(xtable(Messages[1:5,c("From","To","Text")],tabular.environment='longtable'), 
       main="A slice of data from the Messages frame")
#print(xtable(Messages[1:5,c("From","To","Message")]), type="html", 
#      main="A slice of data from the Messages frame")
```

Let's look at some of the message counts. It can be used to gauge the activity and social dynamics in the network.
```{r de2,  fig.cap="Heatmap of messages between individuals and groups in the social network "}
mcount <- ddply(Messages,.(From,To),nrow)
colnames(mcount) <- c("From", "To", "Count")
base_size <- 10
(ggplot(mcount, aes(To,From)) 
   + geom_tile(aes(fill = Count), colour = "white")
   + scale_fill_gradient(low = "#eeeeee", high = "steelblue")
   + theme_grey(base_size = base_size)
   + theme(
       axis.ticks = element_blank()
     , axis.text.x = element_text(
          size = base_size * 0.8
        , angle = 330
        , hjust = 0
        , colour = "grey50")))
```

Who is most active? With not too many people a plot can highlight the most enthusiastic users of the social network. This does not mean they are people of influence, but indicates that they are worth investigating.
```{r de3,  fig.cap="Messages sent by individuals in the social network" }
(ggplot(Messages, aes(x=From)) + geom_bar() + labs(x = "", y = "")
  + theme_grey(base_size = base_size)
  + theme(
       legend.position = "none"
     , axis.ticks = element_blank()
     , axis.text.x = element_text(
          size = base_size * 0.8
        , angle = 330
        , hjust = 0
        , colour = "grey50")))
```

Similarly, who receives most messages. For individuals it may mean that they are valuable members of the community, depending on context.
```{r de4,  fig.cap="Messages sent to individuals and groups in the social network" }
(ggplot(Messages, aes(x=To)) + geom_bar() + labs(x = "", y = "") 
  + theme_grey(base_size = base_size)
  + theme(
       legend.position = "none"
     , axis.ticks = element_blank()
     , axis.text.x = element_text(
          size = base_size * 0.8
        , angle = 330
        , hjust = 0
        , colour = "grey50")))
```

Social Network Analysis
=======================

This document will give a walkthrough of how to do Social Network Analysis using the knet package by example. 

Let's generate an undirected tree graph with 150 nodes and 4 children max per node. This can represent a regular SME company structure.

```{r ic1}
tr <- graph.tree(200, children = 4, mode="undirected")
```

Create a graph from the tree by adding 200 random edges. It is not guaranteed that there won't be fetures like multiple edges between two nodes or loop edges due to the sampling technique used.
```{r ic2}
#gr <- add.edges(tr
#          , as.list( sample(V(tr),100,replace=TRUE)
#                   , sample(V(tr),100,replace=TRUE)
#                   ))
gr <- tr
```

Simplify the graph by removing multiple edges and loops.
```{r ic3}
gr <- simplify(gr, remove.multiple=TRUE, remove.loops=TRUE)
```

## Network centralization measures

The *igraph* package implements a battery of different network measures usually used in Social Network Analysis. We will demonstrate some of them below for completeness.

We can calculate the degree centralisation of the generated tree
```{r ncm1}
cD <- centralization.degree(tr, normalized = FALSE)
```

Calculate the normalized degree centralisation of the generated graph
```{r ncm2}
cDn <- centralization.degree(tr, normalized = TRUE)
```

As a comparison calculate the degree centralisation of the generated graph
```{r ncm3}
cDgr <- centralization.degree(gr, normalized = FALSE)
cDgrn <- centralization.degree(gr, normalized = TRUE)
```

```{r ncm4, message=FALSE, results='asis'}
centrality = as.data.frame(
  rbind(
      "tree" = list("centrality" = cD$centralization)
    , "tree - normalized" = list(cDn$centralization)
    , "graph" = list(cDgr$centralization)
    , "graph - normalized" = list(cDgrn$centralization)
    , "theoretical maximum" = cD$theoretical_max)
  )
```
```{r ncm4_1, message=FALSE, results='asis', marginfigure = TRUE}
print( centrality
       ,include.rownames = TRUE
       ,comments = FALSE
       ,floating.environment='margintable'
       ,table.placement=NULL
     )
```


Next will plot the histogram of the distribution of the degrees of the nodes, together with the *mean* and the *median*. In order tro do that, we first have to cast the calculated degrees *cD$res* to a data frame. Next we build the plot expression piecewise using the appropriate grammar for graphics (*ggplot2*) combinators for histogram and vertical lines.
```{r fig1, tidy = FALSE, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = "Degree centrality of individual nodes with the mean degree plotted in red and the median in green", prompt=FALSE}
degrees <- cDgr$res
degrees <- as.data.frame(degrees)

cdf <- ddply(degrees, "degrees", summarise, degrees.mean=mean(degrees))

( ggplot(degrees, aes(x=degrees))
+ geom_histogram(binwidth = 1) 
+ geom_vline(xintercept=mean(degrees$degrees), color="red")
+ geom_vline(xintercept=median(degrees$degrees), color="green"))
```

Note that the plot is generated as a side effect of an expression, which is a result of the convenient syntax for adding features to a plot using *+* operotor. To prove the point and demonstrate a different useful plot, below is the code to plot the densitity of the degree centrality distribution of the graph, overlayed with a histogram of the density.


```{r fig1-1, tidy = FALSE, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = "Density of the degree centrality distribution", prompt=FALSE}

p <- ( ggplot(degrees, aes(x=degrees)) 
  # Histogram with density instead of count on y-axis
+ geom_histogram(aes(y=..density..),
                 binwidth=1,)
  # Overlay with transparent density plot
+ geom_density(alpha=.5, fill="#DDDDDD")) 

p
```


Calculate closeness centralization of the tree
```{r ncm6}
cC <- centralization.closeness(tr,normalized = FALSE)

#print the calculated centralization
print(cC$centralization)
```

Plot the histogram of the closeness for individual nodes of the tree
```{r fig3, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = "Distribution of the closeness centrality of individual nodes", prompt=FALSE}
closeness <- cC$res
closeness <- as.data.frame(closeness)
( ggplot(closeness, aes(x=closeness))
+ geom_histogram(binwidth = 0.02) 
+ geom_vline(xintercept=mean(closeness$closeness), color="red")
+ geom_vline(xintercept=median(closeness$closeness), color="green")
)
```

Calculate closeness centralization of the generated graph
```{r ncm8}
cCgr <- centralization.closeness(gr,normalized = FALSE)

#print the calculated centralization
print(cCgr$centralization)
```


Calculate the graph betweenness centralization
```{r ncm10}
cB <- centralization.betweenness (tr, directed = FALSE, normalized = FALSE)

#print the calculated centralization
print(cB$centralization)
```

Plot the histogram of the betweenness centrality of individual nodes, taking care to adjust the bins to sufficiently high value:
```{r  fig5, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = "Distribution of the betweenness centrality of individual nodes", prompt=FALSE}
betweenness <- cB$res
betweenness <- as.data.frame(betweenness)
( ggplot(betweenness, aes(x=betweenness))
+ geom_histogram(binwidth = 2000) 
+ geom_vline(xintercept=mean(betweenness$betweenness), color="red")
+ geom_vline(xintercept=median(betweenness$betweenness), color="green")
)
```

Calculate the graph betweenness centralization
```{r }
cBgr <- centralization.betweenness (gr, directed = FALSE, normalized = FALSE)

#print the calculated centralization
print(cBgr$centralization)
```

##  Clustering and cliques

The *transitivity* function from the *igraph* package calculates the clustering coefficient of the graph
```{r }
clusteringC <- transitivity(tr,type="globalundirected")

#print the calculated clustering coefficient of the tree
print(clusteringC)
```

Find the largest cliques in the graph
```{r}
grC <- largest.cliques(gr)
```

Plot the graph with the cliques coloured in different colours.

```{r  fig7, fig.width=7, fig.height=6}
#a list of coulour to help with plotting the graphs
colours = c("#E4B9CD","#BF6D92","#8F305B","#5F0930"
           ,"#FFD6CF","#E38F82","#AA4839","#71190B"
           ,"#ACD3B8","#60A876","#2A7E43","#08541F"
           ,"#DFF1C4","#ACD077","#729C34","#41680A"
           ,"#B9E4CD","#6DBF92","#308F5B","#095F30"
           ,"#B9CDE4","#6D92BF","#305B8F","#09305F"          )

#set all vertice colours to white
V(gr)$color <- "white"

#for all cliques set the corresponding vertice colour
for (i in 1:length(grC)) {
  sel <- grC[[i]]
  V(gr)[sel]$color <- colours[i]
}

#plot the result
knet.plot.graph(gr)
```

Plot a clique in a separate graph
```{r  fig8, fig.width=7, fig.height=6}
 # select the first clique
 sel <- grC[[1]]
 V(gr)$color <- "white"
 V(gr)[sel]$color <- "darkorchid"
 knet.plot.graph(gr)
```


Find communities in the generated graph using a model from statistical mechanics called spin-glass and change vertex colour to reflect the dicovered communities.
```{r fig9,  fig.width=7, fig.height=6}

#discover the communities in the graph using the spinglass method
grc <- spinglass.community(gr)
```
Plot the histogram of the community membership distribution
```{r  fig10, fig.width=7, fig.height=6}
hist(grc$membership, main="Histogram of community membership")
```

Plot the graph with the communities coloured in different colours.

```{r  fig11, fig.width=7, fig.height=6}
#transfer the membership attribute from the communities object to the graph

colours = sample( rainbow( length(grc) + 1) )
V(gr)$membership <- grc$membership

#set all vertice colours to white
V(gr)$color <- "white"

# for each vertice select colour according tho its membership propery (clique number)
V(gr)$color <- colours[V(gr)$membership]
#plot the graph using the knet graph plot helper function
knet.plot.graph(gr)
```

Plot the communities detected in the graph
```{r  fig12, fig.width=7, fig.height=6}
plot(grc,gr, vertex.label=NA, vertex.size=5)

```

Use a different community detection method - fastgreedy algorithm, for a list of other community detection algorithms and related references check the (igraph documention)[http://igraph.org]
```{r  fig13, fig.width=7, fig.height=6}
gfc <- fastgreedy.community(gr)
```

Plot the membership histogram
```{r  fig14, fig.width=7, fig.height=6}
hist(gfc$membership, main="Histogram of the fastgreedy community membership")
```

Plot the graph with the communities coloured in different colours.
```{r  fig15, fig.width=7, fig.height=6}
plot(gfc,gr, vertex.label=NA, vertex.size=5)
```

Plot the dendogram of the community hierarchy
```{r  fig16, fig.width=10, fig.height=8}
dendPlot(gfc)
```


References
--------------------------------------------------------------------
