---
title: "KNOWNET - a guide to data mining and social network analysis"
author: Vladimir Zlatanov
organization: Brunel University
output:
  tufterhandout::pdf_tufte_handout:
    keep_tex: false
  tufterhandout::html_tufte_handout:
    keep_md: true
bibliography: bibliography.bib
csl: harvard-style.csl
---


```{r setup, include=FALSE}
library(igraph)  # graph manipulation and anlysis
library(knet)    # KNOWNET helper utilities
library(ggplot2) # Format R data frames as LaTeX/HTML tables
library(xtable)  # Produce a flowchart.
library(diagram) # Produce a flowchart.

opts_chunk$set(cache=TRUE) # caching of document output - could speed up the results
```

Introduction
=========================

This is a step by step guide on analysis and data minining developed for the needs of the KNOWNET project^[More information is avalable on the KNOWNET project website http://www.knownet.org.uk]. Basic familiarity with R [@RCoreTeam2014] would be helpful, but not essential. This document is a [literate program](http://en.wikipedia.org/wiki/Literate_programming) [@knuth1992] written in R and RMarkdown [@RStudio2014]. R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. As it provides a rich variety of tools in order to perform a variety of data mining, knowledge discovery and social network analysis tasks it was chosen as an implementation language. RStudio IDE is a powerful and productive open source user interface for R that works on Windows, MacOS, and Linux.

In order to be able to follow the guide and perform the excercises the following prerequisties ahave to be installed:  

* [R](http://www.r-project.org/) from the R Project [@RCoreTeam2014] 
* [RStudio IDE](http://www.rstudio.com) from RSrudio Inc [@RStudio2012] 
* [Pandoc](http://johnmacfarlane.net/pandoc/)^[Pandoc is a document processor/converterrequired to generetate this guide and documentation]
* [MiKTeX](http://miktex.org/)^[MikTeX is an up-to-date implementation of TeX/LaTeX and related programs for Windows (all current variants)] or another up-to-date TeX/LaTex distribution

All the required programs are available for Windows, Linux and MacOS X, but the help of a systems administrator to install the software may be required.

This guide is based on the classic Data Mining (DM) and Knowledge Discovery in Databases (KDD) processes [@Fayyad1996], consists of the following steps for exploratory analysis^[The process is repeated until the results are satisfactory] : 
 
  1. Aquisition
  1. Selection 
  2. Pre-processing 
  3. Anonymisation 
  4. Transformation 
  5. Analysis 
  6. Interpretation/Evaluation 



Social Network Analysis
=======================

This document will give a walkthrough of how to do Social Network Analysis using the knet package by example. 

Let's generate an undirected tree graph with 150 nodes and 4 children max per node. This can represent a regular SME company structure.

```{r ic1}
tr <- graph.tree(200, children = 4, mode="undirected")
```

Create a graph from the tree by adding 200 random edges. It is not guaranteed that there won't be fetures like multiple edges between two nodes or loop edges due to the sampling technique used.
```{r ic2}
gr <- add.edges(tr
          , as.list( sample(V(tr),100,replace=TRUE)
                   , sample(V(tr),100,replace=TRUE)
                   ))
```

Simplify the graph by removing multiple edges and loops.
```{r ic3}
gr <- simplify(gr, remove.multiple=TRUE, remove.loops=TRUE)
```

Network centralization measures
--------------------------------------------------------------------
The *igraph* package implements a battery of different network measures usually used in Social Network Analysis. We will demonstrate some of them below for completeness.

We can calculate the degree centralisation of the generated tree
```{r ncm1}
cD <- centralization.degree(tr, normalized = FALSE)
```

Calculate the normalized degree centralisation of the generated graph
```{r ncm2}
cDn <- centralization.degree(tr, normalized = TRUE)
```

As a comparison calculate the degree centralisation of the generated graph
```{r ncm3}
cDgr <- centralization.degree(gr, normalized = FALSE)
cDgrn <- centralization.degree(gr, normalized = TRUE)
```

```{r ncm4, message=FALSE, results='asis'}
centrality = as.data.frame(
  rbind(
      "tree" = list("centrality" = cD$centralization)
    , "tree - normalized" = list(cDn$centralization)
    , "graph" = list(cDgr$centralization)
    , "graph - normalized" = list(cDgrn$centralization)
    ,"theoretical maximum" = cD$theoretical_max)
  )
```
```{r ncm4_1, message=FALSE, results='asis', marginfigure = TRUE}
print( centrality
       ,include.rownames = TRUE
       ,comments = FALSE
       ,floating.environment='margintable'
       ,table.placement=NULL
     )
```


Next will plot the histogram of the distribution of the degrees of the nodes, together with the *mean* and the *median*. In order tro do that, we first have to cast the calculated degrees *cD$res* to a data frame. Next we build the plot expression piecewise using the appropriate grammar for graphics (*ggplot2*) combinators for histogram and vertical lines.
```{r fig1, tidy = TRUE, fig.width = 4, fig.height = 4, marginfigure = TRUE, fig.cap = "Degree centrality of individual nodes with the mean degree plotted in red and the median in green", prompt=FALSE}
degrees <- cDgr$res
degrees <- as.data.frame(degrees)

p <- (ggplot(degrees, aes(x=degrees)) + geom_histogram(binwidth = 1) 
  + geom_vline(xintercept=mean(degrees$degrees), color="red")
  + geom_vline(xintercept=median(degrees$degrees), color="green"))
p
```


Calculate closeness centralization of the tree
```{r ncm6}
cC <- centralization.closeness(tr,normalized = FALSE)

#print the calculated centralization
print(cC$centralization)
```

Plot the histogram of the closeness for individual nodes of the tree
```{r fig3, fig.width=7, fig.height=6}
hist(cC$res, main="Distribution of the closeness centrality of individual nodes")
```

Calculate closeness centralization of the generated graph
```{r ncm8}
cCgr <- centralization.closeness(gr,normalized = FALSE)

#print the calculated centralization
print(cCgr$centralization)
```

Plot the histogram of the closeness for individual nodes of the generated graph
```{r  fig4, fig.width=7, fig.height=6}
hist(cCgr$res, main="Distribution of the closeness centrality of individual nodes")
```

Calculate the graph betweenness centralization
```{r ncm10}
cB <- centralization.betweenness (tr, directed = FALSE, normalized = FALSE)

#print the calculated centralization
print(cB$centralization)
```

Plot the histogram of the betweenness centrality of individual nodes
```{r  fig5, fig.width=7, fig.height=6}
hist(cB$res, main="Distribution of the betweenness centrality of individual nodes")
```

Calculate the graph betweenness centralization
```{r }
cBgr <- centralization.betweenness (gr, directed = FALSE, normalized = FALSE)

#print the calculated centralization
print(cBgr$centralization)
```

Plot the histogram of the betweenness centrality of individual nodes
```{r  fig6, fig.width=7, fig.height=6}
hist(cBgr$res, main="Distribution of the betweenness centrality of individual nodes")
```

Clustering and cliques
--------------------------------------------------------------------

The *transitivity* function from the *igraph* package calculates the clustering coefficient of the graph
```{r }
clusteringC <- transitivity(tr,type="globalundirected")

#print the calculated clustering coefficient of the tree
print(clusteringC)
```

Find the largest cliques in the graph
```{r}
grC <- largest.cliques(gr)
```

Plot the graph with the cliques coloured in different colours.

```{r  fig7, fig.width=7, fig.height=6}
#a list of coulour to help with plotting the graphs
colours = c("#E4B9CD","#BF6D92","#8F305B","#5F0930"
           ,"#FFD6CF","#E38F82","#AA4839","#71190B"
           ,"#ACD3B8","#60A876","#2A7E43","#08541F"
           ,"#DFF1C4","#ACD077","#729C34","#41680A"
           ,"#B9E4CD","#6DBF92","#308F5B","#095F30"
           ,"#B9CDE4","#6D92BF","#305B8F","#09305F"          )

#set all vertice colours to white
V(gr)$color <- "white"

#for all cliques set the corresponding vertice colour
for (i in 1:length(grC)) {
  sel <- grC[[i]]
  V(gr)[sel]$color <- colours[i]
}

#plot the result
knet.plot.graph(gr)
```

Plot a clique in a separate graph
```{r  fig8, fig.width=7, fig.height=6}
 # select the first clique
 sel <- grC[[1]]
 V(gr)$color <- "white"
 V(gr)[sel]$color <- "darkorchid"
 knet.plot.graph(gr)
```


Find communities in the generated graph using a model from statistical mechanics called spin-glass and change vertex colour to reflect the dicovered communities.
```{r fig9,  fig.width=7, fig.height=6}

#discover the communities in the graph using the spinglass method
grc <- spinglass.community(gr)
```
Plot the histogram of the community membership distribution
```{r  fig10, fig.width=7, fig.height=6}
hist(grc$membership, main="Histogram of community membership")
```

Plot the graph with the communities coloured in different colours.

```{r  fig11, fig.width=7, fig.height=6}
#transfer the membership attribute from the communities object to the graph

colours = sample( rainbow( length(grc) + 1) )
V(gr)$membership <- grc$membership

#set all vertice colours to white
V(gr)$color <- "white"

# for each vertice select colour according tho its membership propery (clique number)
V(gr)$color <- colours[V(gr)$membership]
#plot the graph using the knet graph plot helper function
knet.plot.graph(gr)
```

Plot the communities detected in the graph
```{r  fig12, fig.width=7, fig.height=6}
plot(grc,gr, vertex.label=NA, vertex.size=5)

```

Use a different community detection method - fastgreedy algorithm, for a list of other community detection algorithms and related references check the (igraph documention)[http://igraph.org]
```{r  fig13, fig.width=7, fig.height=6}
gfc <- fastgreedy.community(gr)
```

Plot the membership histogram
```{r  fig14, fig.width=7, fig.height=6}
hist(gfc$membership, main="Histogram of the fastgreedy community membership")
```

Plot the graph with the communities coloured in different colours.
```{r  fig15, fig.width=7, fig.height=6}
plot(gfc,gr, vertex.label=NA, vertex.size=5)
```

Plot the dendogram of the community hierarchy
```{r  fig16, fig.width=10, fig.height=8}
dendPlot(gfc)
```

Ploting
--------------------------------------------------------------------

Knowing the root element of the tree *tr* , in this case 1, we can plot the tree
```{r  fig18, fig.width=7, fig.height=6}
knet.plot.tree(tr,1)
```

Or we can plot it as a *regular* graph
```{r  fig19, fig.width=7, fig.height=6}
knet.plot.graph(tr)
```

Plot the two graph in a circular layout
```{r  fig20, fig.width=7, fig.height=6}
knet.plot.circular(tr)
```
```{r  fig21, fig.width=7, fig.height=6}
knet.plot.circular(gr)

```

References
--------------------------------------------------------------------
